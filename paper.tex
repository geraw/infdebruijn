\documentclass{article}
%\documentclass[letterpaper, 10 pt, conference]{ieeeconf}  

%\IEEEoverridecommandlockouts        % This command is only needed if you want to use the \thanks command
%\overrideIEEEmargins                        % See the \addtolength command later in the file to balance the column lengths


% Name clashes workaround
%\makeatletter
%\let\IEEEproof\proof
%\let\IEEEendproof\endproo f
%\let\proof\@undefined
%\let\endproof\@undefined
%\makeatother




\usepackage{epsfig} 
\usepackage{amsmath} 
\usepackage{amssymb} 
\usepackage{amsthm}  
\usepackage{hyperref}
\usepackage{tikz}
\usetikzlibrary{automata,arrows,decorations.pathmorphing,decorations.markings,positioning}
\usetikzlibrary{shapes}
%\usepackage{balance}
\usepackage{scrextend}
\addtokomafont{labelinglabel}{\sffamily}


% Theorem like env.
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}     
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{example}[theorem]{Example}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{corrolary}[theorem]{Corrolary}



%\newcommand{\RotateLeft}{rlft}
\DeclareMathOperator{\RotateLeft}{RotLft}



%------------------------------------------- preamble ---------------------------

\newcommand{\R}{{\mathbb{R}}}
\newcommand{\N}{{\mathbb{N}}}
\newcommand{\Z}{{\mathbb{Z}}}

\newcommand{\REF}[2]{#1~\ref{#2}}

\newcommand{\T}[1]{\langle{#1}\rangle}
\newcommand{\rr}[2]{R^{#2}({#1})}
\newcommand{\rl}[2]{R^{-{#2}}({#1})}


\newcommand{\AorB}[2]{\bigl(#2\text{?}A(#1)\text{:}B(#1)\bigr)}

\usepackage{amssymb} 
\usepackage{algpseudocode,algorithm}
\usepackage{subfigure}

\newcommand{\nega}   [1]{\overline{#1}}
\newcommand{\companion}{comp}
\newcommand{\shlsame}[1]{shl\text{-}same(#1)}
\newcommand{\shlopp} [1]{shl\text{-}opp(#1)}
\newcommand{\shlone} [1]{shl\text{-}one(#1)}
\newcommand{\shlzero}[1]{shl\text{-}zero(#1)}
\newcommand{\idx}    [1]{idx(#1)}


%\pagestyle{plain}


\title{An Efficient Construction of the Prefer-Max Sequence and of an Infinite de Bruijn Sequence}

\author{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\maketitle

\section{Introduction}

A $k$-ary de Bruijn sequence of span $n$ is a cyclic sequence of length $k^n$ in which each $k$-ary string of length $n$ appears exactly once as
a substring. A well known construction of such a sequence was first proposed by Ford~\cite{Ford1957} as follows:

\begin{algorithm}
Repeatedly append the maximal symbol such that the word formed by the $n$ most recent symbols is new (in the first $n$ steps, act as if thee are $n$ invisible zeros before the sequence). Stop after appending $n$ consecutive zeros. 
\caption{The prefer-max sequence.}
\end{algorithm}


For example, if we choose $k=3$ and $n=3$ we get the sequence:
$$\langle2,2,2,1,2,2,0,2,1,1,2,1,0,2,0,1,2,0,0,1,1,1,0,1,0,0,0\rangle.$$
Note that this sequence begins with a prefix (the first $19$ symbols) that contains all the words in $\{0,1,2\}^n \setminus \{0,1\}^n$  (the words that contain the symbol $2$) as substrings. Note also that the rest of the sequence, after this prefix, is exactly the sequence that we would have obtained if we ran the construction with the alphabet $k=2$ (and the same $n$). The first result of this paper, that we call the Onion lemma, is that this is not a coincidence:

\begin{theorem}[Onion]
	For any $k,n \in \N$, the prefix of length $k^n-(k-1)^n$ of the sequence generated by the prefer-max construction is such that its $n$-length substrings are exactly $\{0,\dots,k\}^n \setminus \{0,\dots,k-1\}^n$, i.e., all the words of length $n$ that contain the symbol $k$. Furthermore, the suffix that begins with the 
	$(k^n-(k-1)^n+1)$th symbols is exactly the sequence generated by the prefer-max construction with the parameters $k-1$ and $n$.
	\label{thm:onion}
\end{theorem}

This observation lead us to look at the reverse of the prefer-max sequence. Specifically, the structure identified in Theorem~\ref{thm:onion} means that if we somehow manage to construct the sequence backwards, we do not have to specify $k$ ahead of time because we can go on indefenitiley while $k$ grows in layers: we first write $0^n$, then a word whose substrings of length $n$ are $\{0,1\}^n$, then extend with other words in $\{0,1,2\}^n$, and so on.

The second contribution of this work is then an efficient construction of this reversed sequence. This is formulated in Algorithm~\ref{inf-construction}. We say that this construction is efficient because each step can be computed in $O(n^2)$ operations by enumerating all the $n$ rotations of $\sigma w$ and by comparing them lexicographically (reading each word from right to left).


\begin{algorithm}[!h]
	Append $n$ zeros. Then, repeatedly, let $\sigma w$ be the word formed by the $n$ most recent symbols. Append $\sigma+1$ if $(\sigma+1)w$ is of the form $u0^l$ where $0^lu$ is maximal in right-to-left lexicographic order among all of its rotations. If $(\sigma+1)w$ is not of that form and $\sigma w$ is, append the symbol $0$. Otherwise, if neither $(\sigma+1)w$ nor $(\sigma)w$ are of that form, append $\sigma$.
	\caption{An infinite de Bruijn sequence.}
	\label{inf-construction}
\end{algorithm}

The fact that this generates the reverse of the prefer-max sequence is formulated in the following theorem:
 
\begin{theorem} 
The first $k^n$ symbols generated by Algorithm~\ref{inf-construction} form the reverse of the sequence generated by the prefer-max construction with the parameters $k$ and $n$.	
\end{theorem} 

In particular, the above theorem says that the sequence generated by Algorithm~\ref{inf-construction} is a de Bruijn sequence, i.e., that each word in $\N^n$ appears exactly once as a substring.

While our main focus is on analyzing the reversed sequence, we also have a result about the prefer-max sequence itself. Our result gives the first (to the best of our knowledge) efficient construction of that sequence:

\begin{algorithm}
	Append $n-1$ zeros and then the symbol $k$. Then, repeatedly, let $\sigma w$ be the word formed by the $n$ most recent symbols. Append the symbol $\sigma-1$  if $\sigma w$  is of the form specified in Algorithm~\ref{inf-construction}. Otherwise, if there is a  $\sigma'$ such that $\sigma'w$ is of that form, append the maximal such $\sigma'$. Otherwise, if there is no such $\sigma'$, append the symbol $\sigma$.
		
	\caption{An efficient construction of the prefer-max sequence.}
	\label{efficient-pref-max}
\end{algorithm}

Each step of Algorithm~\ref{efficient-pref-max} can be computed in $O(n^2)$ time because it suffices to examine for $\sigma'$ only symbols that are in $\sigma w$ or are smaller by one than a symbol in $\sigma w$, as we will establish later in the paper.
The fact that this is indeed the prefer-max sequence is stated in the following theorem:

\begin{theorem}
	The sequence generated by Algorithm~\ref{efficient-pref-max} is the prefer-max sequence with parameters $k$ and $n$.
\end{theorem}
	

A central tool to our analysis of the sequences descibed above is an alternative formulation of the prefer-max sequence. For this, we need to introduce some language, as follows.

The $n$ dimensional infinite de Bruijn graph is the graph $G_{n}=\T{V,E}$ where $V=\N^n$ and $E=\{ \T{\sigma_1 w, w \sigma_2} \colon \sigma_1,\sigma_2\in\N, w \in \N^{n-1}\}$. The de Bruijn sequences, defined in the beginning of this paper, are in one-to-one correspondence with the Hamiltonian cycles in the de Bruijn graph, as follows: (1) Concatenating the first letter of each vertex in a cycle produces a de Bruijn sequence of order $n$; and (2) A cycle can be constructed from a de Bruijn sequence $\T{\sigma_1,\dots,\sigma_{2^n}}$ of order $n$ by visiting the vertex $\sigma_1\cdots\sigma_n$, then $\sigma_2\cdots\sigma_{n+1}$ and so on.

Let $rtl(\sigma_1\sigma_2\dots\sigma_n) = \sigma_2\dots\sigma_n\sigma_1$ denote the rotation of a word to the left and let $rtl^i(w)$ denote a rotation of $i$ letters to the left. A \emph{necklace} in the de Bruijn graph $G_n$ is the set $\{rtl^i(w)\}_{i=1}^n$ where $w \in \N^n$, i.e., it is an equivalence class of $n$-character strings over $\N$ when strings that are rotations of each other are considered equivalent. A $w\in\N^n$ is called a \emph{key word} if it is larger in right-to-left lexicographic order than all of its rotations (all the words in its necklace).  Note the resemblance of this to the notion of Lyndon words~\cite{Lyndon1954}, on which we will elaborate later.

We are now ready to introduce another construction:


\begin{algorithm}[!h]
	Start with the one element sequence $\T{0^n}$. The sequence at the $i$th step is constructed by adding words to the previous sequence as follows: Let $k_i$ be the $i$th key word in right-to-left lexicographic order. Let $l$ be the number of leading zeros in $k_i$ ($l$ may be zero) and let $\sigma \in \N$ and $w\in\N^{n-l-1}$ be such that $k_i=0^l(\sigma+1)w$. Now, add the sub-sequence $\T{rtl^i(w0^l(\sigma+1))}_{i=0}^{n-1}$ between the word $\sigma w 0^l$ and its follower in the previously constructed sequence.
	\caption{A necklace joining construction.}
	\label{necklace-joining}
\end{algorithm}

To following proposition establishes that the above construction describes an infinite sequence of words:

\begin{proposition}
	For every $l>0$ there is $m>0$ such that for every $i>m$ the insertions of words at the $i$th step of Algorithm~\ref{necklace-joining} are all after the $l$th element of the sequence.
\end{proposition}

Let $S=\T{w_i}_{i=0}^\infty$ be the infinite sequence all whose prefixes agree with infinitely many prefixes of the finite sequences generated at the steps of Algorithm~\ref{necklace-joining}. Since every word is a rotation of some key word, we have that this sequence contains all the words in $\N^n$. Since there is a directed edge in $G_n$ from each word in this sequence to its follower, the sequence corresponds to an Hamiltonian path in $G_n$. The following theorem states that this path maps, by the standard correspondence described above, to the reverse of the prefer-map sequence:

\begin{theorem}
	If we take the first letter of each word in $S$ we get the sequence described in Algorithm~\ref{inf-construction}.
\end{theorem}

This result allows for another construction of the reversed prefer-max sequence, as follows. By the definition of the necklace joining construction, shown in Algorithm~\ref{necklace-joining}, one can infer that key words appear in lexicographic order and that the distance between one key words to the next is the size of the necklace of the latter. For a word $w\in\N^n$, the \emph{primitive root} of $w$ is the  unique primitive (non-periodic) word $\rho(w)$ such that $w = \rho(w)^l$ for some $l \geq 1$. Since the length of the primitive root of a ket word is the length of its cycle, we get the following construction:


\begin{algorithm}[!h]
	Construct an infinite sequence of symbols by concatenating the primitive roots  of the key words of length $n$ in left-to-right lexicographic order.
	\caption{Word concatenation construction.}
	\label{word-concatenation}
\end{algorithm}

As the reader may expect, our result is this sequence is also the reverse of the prefer-max sequence:

\begin{theorem}
	The sequence described in Algoithm~\ref{word-concatenation} is the same sequence described in Algorithm~\ref{inf-construction}.
\end{theorem}

The last result is similar in nature to the theorem of Fredricksen and Maiorana in~\cite{Fredricksen1978} (see also~\cite{Moreno2004} and~\cite{Moreno2015}).	
These papers show that the concatenation in lexicographic order of the Lyndon words (words that are minimal in lexicographic among their rotations) of length dividing $n$ produces a de Bruijn sequence of span $n$, and that this word is lexicographically minimal among all de Bruijn sequences of span $n$. In another paper~\cite{Fredricksen1970}, Fredricksen proves that (in the binary case) the prefer-max (there called Ford) sequence is the lexicographically least sequence. With appropriate mapping (changing the order of the letters and the direction of reading words when considering lexicographic order) our last result can be regarded as an alternative proof of the result identified by Fredricksen and Maiorana.


\bibliography{library}{}
\bibliographystyle{plain}

\end{document}

