\documentclass{article}
%\documentclass[letterpaper, 10 pt, conference]{ieeeconf}  

%\IEEEoverridecommandlockouts        % This command is only needed if you want to use the \thanks command
%\overrideIEEEmargins                        % See the \addtolength command later in the file to balance the column lengths


% Name clashes workaround
%\makeatletter
%\let\IEEEproof\proof
%\let\IEEEendproof\endproo f
%\let\proof\@undefined
%\let\endproof\@undefined
%\makeatother




\usepackage{epsfig} 
\usepackage{amsmath} 
\usepackage{amssymb} 
\usepackage{amsthm}  
\usepackage{hyperref}
\usepackage{tikz}
\usetikzlibrary{automata,arrows,decorations.pathmorphing,decorations.markings,positioning}
\usetikzlibrary{shapes}
%\usepackage{balance}
\usepackage{scrextend}
\addtokomafont{labelinglabel}{\sffamily}


% Theorem like env.
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}     
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{example}[theorem]{Example}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{corrolary}[theorem]{Corrolary}



%\newcommand{\RotateLeft}{rlft}
\DeclareMathOperator{\RotateLeft}{RotLft}



%------------------------------------------- preamble ---------------------------

\newcommand{\R}{{\mathbb{R}}}
\newcommand{\N}{{\mathbb{N}}}
\newcommand{\Z}{{\mathbb{Z}}}

\newcommand{\REF}[2]{#1~\ref{#2}}

\newcommand{\T}[1]{\langle{#1}\rangle}
\newcommand{\rr}[2]{R^{#2}({#1})}
\newcommand{\rl}[2]{R^{-{#2}}({#1})}


\newcommand{\AorB}[2]{\bigl(#2\text{?}A(#1)\text{:}B(#1)\bigr)}

\usepackage{amssymb} 
\usepackage{algpseudocode,algorithm}
\usepackage{subfigure}



%\pagestyle{plain}


\title{An Infinite de Bruijn Sequence}

\author{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\maketitle

\section{Introduction}

A $k$-ary de Bruijn sequence of span $n$ is a cyclic sequence of length $k^n$ in which each $k$-ary string of length $n$ appears exactly once as
a substring. A well known construction of such a sequence was proposed by Ford ~\cite{Ford57} as follows:

\begin{algorithm}
Repeatedly append the symbol $k-1$ if the word formed by the $n$ most recent symbols (padded with zeros on the left, if not enough symbols exist) is new, otherwise append $k-2$, otherwise $k-3$, etc. Stop after appending $n$ consecutive zeros. 
\caption{The prefer-max construction.}
\end{algorithm}


For example, if we choose $k=3$ and $n=3$ we get the sequence:
$$\langle2,2,2,1,2,2,0,2,1,1,2,1,0,2,0,1,2,0,0,1,1,1,0,1,0,0,0\rangle.$$
Note that this sequence begins with a prefix (the first $19$ symbols) that contains all the words in $\{0,1,2\}^n \setminus \{0,1\}^n$ as substrings. Note also that the rest of the sequence, after this prefix, is exactly the sequence that we would have obtained if we ran the construction with the alphabet $k=2$ (and the same $n$). The first result of this paper, that we call the Onion lemma, is that this is not a coincidence:

\begin{theorem}[Onion]
	For any $k,n \in \N$, the prefix of length $k^n-(k-1)^n$ of the sequence generated by the prefer-max construction is such that its $n$-length substrings are exactly $\{0,\dots,k\}^n \setminus \{0,\dots,k-1\}^n$, i.e., all the words of length $n$ that contain the symbol $k$. Furthermore, the suffix that begins with the 
	$(k^n-(k-1)^n+1)$th symbols is exactly the sequence generated by the prefer-max construction with the parameters $k-1$ and $n$.
	\label{thm:onion}
\end{theorem}

This observation lead us to look at the reverse of the prefer-max sequence. The structure identified in Theorem~\ref{thm:onion} means that if we somehow manage to construct the sequence backwards, we do not have to specify $k$ ahead of time because we can go on indefenitiley while $k$ grows in layers: we first write $0^n$, then a word whose substrings of length $n$ are $\{0,1\}^n$, then extend to $\{0,1,2\}^n$, and so on.

The second contribution of this work is then an efficient construction of this reversed sequence. This is formulated in Algorithm~\ref{inf-construction}. Note that each step of this construction can be computed in $O(n^2)$ operations by enumerating all the $n$ rotations of $\sigma w$ and by comparing them lexicographically (reading each word from right to left).


\begin{algorithm}[!h]
	Append $n$ zeros. Then, repeatedly, let $\sigma w$ be the word formed by the $n$ most recent symbols. Append $\sigma+1$ if $(\sigma+1)w$ is of the form $u0^l$ where $0^lu$ is maximal in right-to-left lexicographic order among all of its rotations. If $(\sigma+1)w$ is not of that form and $\sigma w$ is, append the symbol $0$. Otherwise, if neither $(\sigma+1)w$ nor $(\sigma)w$ are of that form, append $\sigma$.
	\caption{An infinite de Bruijn sequence.}
	\label{inf-construction}
\end{algorithm}

The fact that this generates the reverse of the prefer-max sequence is formulated in the following theorem:
 
\begin{theorem} 
The first $k^n$ symbols generated by Algorithm~\ref{inf-construction} form the reverse of the sequence generated by the prefer-max construction with the parameters $k$ and $n$.	
\end{theorem} 

In particular, the above theorem says that the sequence generated by Algorithm~\ref{inf-construction} is a de Bruijn sequence, i.e., that each word in $\N^n$ appears exactly once as a substring.

While our main focus is on analyzing the reversed sequence, we also have a result about the prefer-max sequence itself. Our result gives the first (to our knowledge) efficient construction for that sequence:

\begin{algorithm}[!h]
	Append $n-1$ zeros and then the symbol $k$. Then, repeatedly, let $\sigma w$ be the word formed by the $n$ most recent symbols. Append the symbol $\sigma-1$  if $\sigma w$  is of the form specified in Algorithm~\ref{inf-construction}. Otherwise, if there is a maximal $\sigma'$ such that $\sigma'w$ is of that form, append the symbol $\sigma'$. Otherwise, if there is no such $\sigma'$, append the symbol $\sigma$.
		
	\caption{An efficient construction of the prefer-max sequence.}
	\label{efficient-pref-max}
\end{algorithm}

Each step of Algorithm~\ref{efficient-pref-max} can be computed in $O(n^2)$ time because it suffices to examine only $\sigma'$s which are symbols in $\sigma w$ or are a symbol that smaller by one than a symbol in $\sigma w$ (see Proposition~\ref{efficiency-of-pref-max} below).
The fact that this is indeed the prefer-max sequence is stated in the following theorem:

\begin{theorem}
	The sequence generated by Algorithm~\ref{efficient-pref-max} is the prefer-max sequence with parameters $k$ and $n$.
\end{theorem}
	

The main tool that brought us to the above results is a formulation of an alternative description of the infinite sequence. For this, we need to introduce some language.


	








\end{document}

